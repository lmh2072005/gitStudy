1. 操作符

git
allitems
 [ 、 ( 、 + 、 - 之前加分号就可以了
html5标准事件


一：操作符
（一）.一元操作符
只能操作一个值的操作符叫做一元操作符
1.递增和递减操作符
a. 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减1的操作。字
符串变量变成数值变量。
eg: var a='1'; ++a;  //a 变成2
b.在应用于一个不包含有效数字字符的字符串时，将变量的值设置为NaN,字符串变量变成数值变量。
eg:var a='1aa';++a  //a 变成NaN
c:在应用于布尔值false时，先将其转换为0再执行加减1的操作。布尔值变量变成数值变量。
eg:var a=false;++a  //a 变成1
d:在应用于布尔值true时，先将其转换为1再执行加减1的操作。布尔值变量变成数值变量。
eg:var a=true;++a  //a 变成2
e:在应用于浮点数值时，执行加减1的操作。
eg：var a=1.1;++a  //a 变成2.1
f:在应用于对象时，先调用对象的valueOf()方法（第5章将详细讨论）以取得一个可供操作的
值。然后对该值应用前述规则。如果结果是NaN，则在调用toString()方法后再应用前述规
则。对象变量变成数值变量。
eg:var a=[];++a; //a变成1；内部操作原则：先把a调用valueOf()如果返回的是对象则再调用toString()，再对结果转换为Number按照一元操作符计算

由此可见对于一元操作符来说都是先把变量转换为Number类型 ，再进行计算。先Number(变量)，再计算。
2. 一元加和减操作符
在对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值执行转换。
换句话说，布尔值false和true将被转换为0和1，字符串值会被按照一组特殊的规则进行解析，而对象是先调用它们的valueOf()和（或）toString()方法，再转换得到的值。
下面的例子展示了对不同数据类型应用一元加操作符的结果：
var s1 = "01"; 
var s2 = "1.1"; 
var s3 = "z"; 
var b = false; 
var f = 1.1; 
var o = { 
valueOf: function() { 
     return -1; 
  } 
}; 
s1 = +s1;  // 值变成数值1 
s2 = +s2;  // 值变成数值1.1 
s3 = +s3;  // 值变成NaN 
b = +b;  // 值变成数值0 
f = +f;  // 值未变，仍然是1.1 
o = +o;  // 值变成数值-1

一元减操作符主要用于表示负数，例如将1转换成-1
在将一元减操作符应用于数值时，该值会变成负数。而当应用于非数值时，
一元减操作符遵循与一元加操作符相同的规则，最后再将得到的数值转换为负数，如下面的例子所示：
var s1 = "01"; 
var s2 = "1.1"; 
var s3 = "z"; 
var b = false; 
var f = 1.1; 
var o = { 
  valueOf: function() { 
    return -1; 
  } 
}; 
s1 = -s1; // 值变成了数值-1 
s2 = -s2; // 值变成了数值-1.1 
s3 = -s3; // 值变成了NaN 
b = -b; // 值变成了数值0 
f = -f; // 变成了-1.1 
o = -o; // 值变成了数值1 
一元加和减操作符主要用于基本的算术运算，也可以像前面示例所展示的一样用于转换数据类型。

（二）位操作符
ECMAScript中的所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位
的整数，然后执行操作，最后再将结果转换回64位。
对于有符号的整数，32位中的前31位用于表示整数的值(最后一位索引为0)。第32位用于表示数值的符号：0表示正数，1表示负数。这个表示符号的位叫做符号位，符号位的值决定了其他位数值的格式。正数以纯二进制格式存储，31位中的每一位都表示2的幂.没有用到的位以0 填充，即忽略不计。
如果对非数值应用位操作符，会先使用Number()函数将该值转换为一个数值（自动完成），然后再应用位操作。得到的结果将是一个数值。
在对特殊的NaN和Infinity值应用位操作时，这两个值都会被当成0来处理
十进制转二进制算法为分步除2取余数，然后余数倒过来得到二进制结果。
例如：

2|__3__   1  //余数为1  
  2|_1_   1  //余数为1
     0  //余数为0

余数倒过来为：011。即十进制3转为二进制为011
_
例如，数值18 的二进制表示是
00000000000000000000000000010010，或者更简洁的10010。
负数同样以二进制码存储，但使用的格式是二进制补码。计算一个数值的二进制补码，需要经过下列3个步骤：
(i) 求这个数值绝对值的二进制码（例如，要求18的二进制补码，先求18的二进制码）；
(ii) 求二进制反码，即将0替换为1，将1替换为0；
(iii) 得到的二进制反码加1。
要根据这3个步骤求得18的二进制码，首先就要求得18的二进制码，即：
0000 0000 0000 0000 0000 0000 0001 0010 
然后，求其二进制反码，即0和1互换：
1111 1111 1111 1111 1111 1111 1110 1101 
最后，二进制反码加1：
1111 1111 1111 1111 1111 1111 1110 1101 
  1 
--------------------------------------- 
1111 1111 1111 1111 1111 1111 1110 1110 
这样，就求得了18的二进制表示，即11111111111111111111111111101110。要注意的是，在处理有符号整数时，是不能访问位31的。
ECMAScript会尽力向我们隐藏所有这些信息。换句话说，在以二进制字符串形式输出一个负数时，
我们看到的只是这个负数绝对值的二进制码前面加上了一个负号。如下面的例子所示：
var num = -18; 
alert(num.toString(2)); // "-10010" 
要把数值18转换成二进制字符串时，得到的结果是"-10010"。这说明转换过程理解了二进制补码并将其以更合乎逻辑的形式展示了出来。
1. 按位非（NOT）由一个波浪线（~）表示
执行按位非的结果就是返回数值的反码
var num1 = 25;   // 二进制00000000000000000000000000011001 
var num2 = ~num1;  // 二进制11111111111111111111111111100110 
alert(num2);  // -26 
这里，对25执行按位非操作，结果得到了26。这也验证了按位非操作的本质：操作数的负值减1。
相当于num2 = -num1 -1
然以上代码也能返回同样的结果，但由于按位非是在数值表示的最底层执行操作，因此速度更快。

2. 按位与（AND）
按位与操作符由一个和号字符（&）表示，它有两个操作符数。从本质上讲，按位与操作就是将两
个数值的每一位对齐，然后根据下表中的规则，对相同位置上的两个数执行AND操作：
------------------------------------------
第一个数值的位  第二个数值的位  结 果
1                  1              1 
1                  0              0 
0                  1              0 
0                  0              0 
------------------------------------------
简而言之，按位与操作只在两个数值的对应位都是1时才返回1，任何一位是0，结果都是0。
下面看一个对25和3执行按位与操作的例子：
var result = 25 & 3; 
alert(result); //1 
可见，对25和3执行按位与操作的结果是1。为什么呢？请看其底层操作：
25  = 0000 0000 0000 0000 0000 0000 0001 1001 
3  = 0000 0000 0000 0000 0000 0000 0000 0011 
--------------------------------------------- 
 AND = 0000 0000 0000 0000 0000 0000 0000 0001 
原来，25和3的二进制码对应位上只有一位同时是1，而其他位的结果自然都是0，因此最终结果
等于1。

3. 按位或（OR）
按位或操作符由一个竖线符号（|）表示，同样也有两个操作数。按位或操作遵循下面这个真值表
------------------------------------------
第一个数值的位  第二个数值的位  结 果
1                  1              1 
1                  0              1 
0                  1              1 
0                  0              0 
------------------------------------------
按位或操作在有一个位是1的情况下就返回1，而只有在两个位都是0的情况下才返回0。
var result = 25 | 3; 
alert(result); //27
25与3按位或的结果是27：
25 = 0000 0000 0000 0000 0000 0000 0001 1001 
3  = 0000 0000 0000 0000 0000 0000 0000 0011 
-------------------------------------------- 
OR = 0000 0000 0000 0000 0000 0000 0001 1011 
这两个数值的都包含4个1，因此可以把每个1直接放到结果中。二进制码11011等于十进制值27。

4. 按位异或（XOR）
按位异或操作符由一个插入符号（^）表示，也有两个操作数。以下是按位异或的真值表。
------------------------------------------
第一个数值的位  第二个数值的位  结 果
1                  1              0 
1                  0              1 
0                  1              1 
0                  0              0 
------------------------------------------
按位异或与按位或的不同之处在于，这个操作在两个数值对应位上只有一个1时才返回1，如果对
应的两位都是1或都是0，则返回0。
对25和3执行按位异或操作的代码如下所示：
var result = 25 ^ 3; 
alert(result); //26 
25与3按位异或的结果是26，其底层操作如下所示：
25  = 0000 0000 0000 0000 0000 0000 0001 1001 
3  = 0000 0000 0000 0000 0000 0000 0000 0011 
--------------------------------------------- 
XOR = 0000 0000 0000 0000 0000 0000 0001 1010

5. 左移
移操作符由两个小于号（<<）表示，这个操作符会将数值的所有位向左移动指定的位数。例如，
如果将数值2（二进制码为10）向左移动5位，结果就是64（二进制码为1000000），代码如下所示：
var oldValue = 2;  // 等于二进制的10 
var newValue = oldValue << 5;  // 等于二进制的1000000，十进制的64 
在向左移位后，原数值的右侧多出了5个空位。左移操作会以0来填充这些空位，以便得到
的结果是一个完整的32位二进制数
左移不会影响操作数的符号位。换句话说，如果将2向左移动5位，结果将是64，而非64

6. 有符号的右移
有符号的右移操作符由两个大于号（>>）表示，这个操作符会将数值向右移动，但保留符号位（即
正负号标记）。有符号的右移操作与左移操作恰好相反，即如果将64向右移动5位，结果将变回2：
var oldValue = 64;  // 等于二进制的1000000 
var newValue = oldValue >> 5;  // 等于二进制的10 ，即十进制的2 
同样，在移位过程中，原数值中也会出现空位。只不过这次的空位出现在原数值的左侧、符号位的
右侧，而此时ECMAScript会用符号位的值来填充所有空位，以便得到一个完整的值

7. 无符号右移
无符号右移操作符由3个大于号（>>>）表示，这个操作符会将数值的所有32位都向右移动。对正
数来说，无符号右移的结果与有符号右移相同。仍以前面有符号右移的代码为例，如果将64无符号右
移5位，结果仍然还是2：
ar oldValue = 64;  // 等于二进制的1000000 
var newValue = oldValue >>> 5;  // 等于二进制的10 ，即十进制的2 

但是对负数来说，情况就不一样了。首先，无符号右移是以0来填充空位，而不是像有符号右移那
样以符号位的值来填充空位。所以，对正数的无符号右移与有符号右移结果相同，但对负数的结果就不
一样了。其次，无符号右移操作符会把负数的二进制码当成正数的二进制码。而且，由于负数以其绝对
值的二进制补码形式表示，因此就会导致无符号右移后的结果非常之大，如下面的例子所示：
var oldValue = -64;  // 等于二进制的11111111111111111111111111000000 
var newValue = oldValue >>> 5;  // 等于十进制的134217726
这里，当对64执行无符号右移5位的操作后，得到的结果是134217726。之所以结果如此之大，
是因为64的二进制码为11111111111111111111111111000000，而且无符号右移操作会把这个二进制码当
成正数的二进制码，换算成十进制就是4294967232。如果把这个值右移5 位，结果就变成了
00000111111111111111111111111110，即十进制的134217726。

（三）布尔操作符
布尔操作符一共有3个：非（NOT）！、与（AND）&& 和或（OR）
1.逻辑非
可以应用于ECMAScript中的任何值，无论这个值是什么数据类型，这个操作符都会返回一个布尔值
逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反。
逻辑非操作符遵循下列规则：
a.如果操作数是一个对象，返回false;  
b.如果操作数是一个空字符串，返回true;
c.如果操作数是一个非空字符串，返回false;
d.如果操作数是数值0，返回true
e.如果操作数是任意非0数值（包括Infinity），返回false;
f.如果操作数是null、NaN、undefined，返回true;
而同时使用两个逻辑非操作符，实际上就会模拟Boolean()转型函数的行为
第一个逻辑非操作会基于无论什么操作数返回一个布尔值，而第二个逻辑非操作则对该布尔值求反，于是就得到了这个值真正对应的布尔值，最终结果与对这个值使用Boolean()函数相同